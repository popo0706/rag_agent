# ===============================================================
# 【要約】
# StrOutputParser を用いて AIMessage（＝「封筒付きの手紙」）から
# content 文字列（＝「手紙の本文」）だけを取り出すサンプル。
#   - ai_message.content も output もどちらも <class 'str'>。
#   - 違いは「封筒の中に入っているか」「取り出した後か」だけ。
#   - 履歴として再利用するときは封筒ごと（AIMessage）、
#     ユーザへ表示・保存するときは本文だけ（str）を使う。
# ===============================================================


# ==============================================================
# LangChain Core から必要なクラスをインポート
# ==============================================================

from langchain_core.messages import AIMessage  # ← “封筒付き” メッセージ
from langchain_core.output_parsers import StrOutputParser  # ← “封筒を開けるハサミ”


# ==============================================================
# StrOutputParser は「AIMessage を受け取って content を str で返す」だけ
# ==============================================================

output_parser = StrOutputParser()  # パーサーを生成


# ==============================================================
# ダミーの AIMessage オブジェクトを作成
# ==============================================================

ai_message = AIMessage(content="私はAIアシスタントです。")  # 「封筒」＋手紙本文


# ==============================================================
# パーサーで AIMessage → str へ変換（invoke は“実行”の意）
# ==============================================================

output = output_parser.invoke(ai_message)  # “封筒”を開けて本文だけ取り出し


# ==============================================================
# 型と中身を確認してみる
# ==============================================================

# --- ① 封筒の中に手紙が入ったまま ------------------------------
print(type(ai_message.content))  # → <class 'str'>
print(ai_message.content)  #   '私はAIアシスタントです。'

# --- ② 封筒から取り出して手に持った手紙 -------------------------
print("-----")  # 区切り線

print(type(output))  # → <class 'str'>（同じ型だが封筒は無い）
print(output)  #   '私はAIアシスタントです。'

# ここでのポイント:
# ・どちらも “ただの文字列” でタイプは同じ。
# ・ai_message.content は AIMessage オブジェクトの一部として
#   履歴に再利用できる（role やメタ情報付き）。
# ・output は 画面表示 / ログ保存 / 正規表現など
#   Python 文字列 API をそのまま使いたい場面で便利。
